/*
 * Copyright (C) 2009 The Android Open Source Project
 * Copyright (C) 2017 The MoKee OpenSource Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include <sys/wait.h>

#include <android-base/strings.h>

#include "edify/expr.h"
#include "updater/install.h"
#include "updater/updater.h"
#include "minzip/Zip.h"
#include "minzip/SysUtil.h"
#include "config.h"

// Generated by the makefile, this function defines the
// RegisterDeviceExtensions() function, which calls all the
// registration functions for device-specific extensions.
#include "register.inc"

// Where in the package we expect to find the actual edify script.
// (Note it's "updateR-script", not the older "update-script".)
#define SCRIPT_NAME "META-INF/com/google/android/updater-script"
// Where in the package we expect to find the edify script for execution.
#define CHECK_SCRIPT_NAME "META-INF/com/google/android/checker-script"
// Recovery API version
#define VERSION 3

// Error codes
// 1 - wrong argument count
// 2 - system error
// 3 - cannot find/open zip
// 4 - script not found in zip
// 5 - script cannot be read from zip
// 6 - script parse error
// 7 - error from execution

extern bool have_eio_error;
struct selabel_handle *sehandle = NULL;

static void mkChecker(State* state, const std::string& buffer) {
    UpdaterInfo* ui = reinterpret_cast<UpdaterInfo*>(state->cookie);

    // "line1\nline2\n" will be split into 3 tokens: "line1", "line2" and "".
    // So skip sending empty strings.
    std::vector<std::string> lines = android::base::Split(buffer, "\n");
    for (auto& line: lines) {
        if (!line.empty()) {
            fprintf(ui->cmd_pipe, "mk_checker %s\n", line.c_str());
        }
    }
}

Value* MKCheckerFn(const char* name, State* state, int argc, Expr* argv[]) {
    if (argc != 2) {
        return ErrorAbort(state, kArgsParsingFailure, "%s() expects 2 args, got %d", name, argc);
    }
    char** args = ReadVarArgs(state, argc, argv);

    std::string buffer = args[0];
    buffer += "=";
    buffer += args[1];
    buffer += "\n";
    mkChecker(state, buffer);
    return StringValue(strdup(buffer.c_str()));
}

int main(int argc, char** argv) {
    // Various things log information to stdout or stderr more or less
    // at random (though we've tried to standardize on stdout).  The
    // log file makes more sense if buffering is turned off so things
    // appear in the right order.
    setbuf(stdout, NULL);
    setbuf(stderr, NULL);

    if (argc != 3) {
        printf("args=unexpected number of arguments (%d)\n", argc);
        return 1;
    }

    // Create log file

    FILE* logf = fopen(argv[2], "w");
    if (logf == NULL) {
        printf("system=cannot create log file\n");
        return 2;
    }

    // Extract the script from the package.

    const char* package_filename = argv[1];
    MemMapping map;
    if (sysMapFile(package_filename, &map) != 0) {
        fprintf(logf, "zip=failed to map package %s\n", argv[1]);
        fprintf(logf, "exit_status=%d\n", 3);
        return 3;
    }
    ZipArchive za;
    int err;
    err = mzOpenZipArchive(map.addr, map.length, &za);
    if (err != 0) {
        fprintf(logf, "zip=failed to open package %s: %s\n", argv[1],
                strerror(err));
        fprintf(logf, "exit_status=%d\n", 3);
        return 3;
    }
    ota_io_init(&za);

    const ZipEntry* script_entry = mzFindZipEntry(&za, SCRIPT_NAME);
    if (script_entry == NULL) {
        fprintf(logf, "find=failed to find %s in %s\n", SCRIPT_NAME,
                package_filename);
        fprintf(logf, "exit_status=%d\n", 4);
        return 4;
    }
    char* script = reinterpret_cast<char*>(malloc(script_entry->uncompLen+1));
    if (!mzReadZipEntry(&za, script_entry, script, script_entry->uncompLen)) {
        fprintf(logf, "read=failed to read script from package\n");
        fprintf(logf, "exit_status=%d\n", 5);
        return 5;
    }
    script[script_entry->uncompLen] = '\0';

    const ZipEntry* check_script_entry = mzFindZipEntry(&za, CHECK_SCRIPT_NAME);
    if (check_script_entry == NULL) {
        fprintf(logf, "find=failed to find %s in %s\n", CHECK_SCRIPT_NAME,
                package_filename);
        fprintf(logf, "exit_status=%d\n", 4);
        return 4;
    }
    char* check_script = reinterpret_cast<char*>
            (malloc(check_script_entry->uncompLen+1));
    if (!mzReadZipEntry(&za, check_script_entry, check_script,
            check_script_entry->uncompLen)) {
        fprintf(logf, "read=failed to read check script from package\n");
        fprintf(logf, "exit_status=%d\n", 5);
        return 5;
    }
    check_script[check_script_entry->uncompLen] = '\0';

    // Configure edify's functions.

    RegisterBuiltins();
    RegisterInstallFunctions();
    RegisterFunction("mk_checker", MKCheckerFn);
    RegisterDeviceExtensions();
    FinishRegistration();

    // Parse the script.

    Expr* root;
    int error_count = 0;
    int error = parse_string(script, &root, &error_count);
    if (error != 0 || error_count > 0) {
        fprintf(logf, "parse=%d errors\n", error_count);
        fprintf(logf, "exit_status=%d\n", 6);
        return 6;
    }

    // Parse the check script.

    error_count = 0;
    error = parse_string(check_script, &root, &error_count);
    if (error != 0 || error_count > 0) {
        fprintf(logf, "checker_parse=%d errors\n", error_count);
        fprintf(logf, "exit_status=%d\n", 6);
        return 6;
    }

    // Set up the pipe for sending commands back to the parent process.

    int pipefd[2];
    int ret = pipe(pipefd);
    if (ret < 0) {
        fprintf(logf, "system=cannot create pipe\n");
        fprintf(logf, "exit_status=%d\n", 2);
        return 2;
    }
    FILE* cmd_pipe = fdopen(pipefd[1], "wb");
    setlinebuf(cmd_pipe);

    // Evaluate the parsed script.

    UpdaterInfo updater_info;
    updater_info.cmd_pipe = cmd_pipe;
    updater_info.package_zip = &za;
    updater_info.version = VERSION;
    updater_info.package_zip_addr = map.addr;
    updater_info.package_zip_len = map.length;

    State state;
    state.cookie = &updater_info;
    state.script = check_script;
    state.errmsg = NULL;

    pid_t pid = fork();

    if (pid == -1) {
        fprintf(logf, "system=cannot fork\n");
        fprintf(logf, "exit_status=%d\n", 2);
        return 2;
    } else if (pid == 0) {
        close(pipefd[0]);
        Evaluate(&state, root);
        return 0;
    }

    fclose(cmd_pipe);

    int err_found = 0;
    char buffer[1024];
    FILE* from_child = fdopen(pipefd[0], "r");
    while (fgets(buffer, sizeof(buffer), from_child) != NULL) {
        char* command = strtok(buffer, " \n");
        if (command == NULL) {
            continue;
        } else if (strcmp(command, "mk_checker") == 0) {
            char* str = strtok(NULL, "\n");
            if (str) {
                fprintf(logf, "%s\n", str);
                err_found = 1;
            } else {
                continue;
            }
        } else {
            continue;
        }
    }
    fclose(from_child);
    int status;
    waitpid(pid, &status, 0);

    if (have_eio_error) {
        fprintf(logf, "system=io error encountered during execution\n");
        fprintf(logf, "exit_status=%d\n", 2);
        return 2;
    }

    if (updater_info.package_zip) {
        mzCloseZipArchive(updater_info.package_zip);
    }
    sysReleaseMap(&map);
    free(script);
    free(check_script);
    fclose(logf);

    if (err_found) {
        fprintf(logf, "exit_status=%d\n", 7);
        return 7;
    } else {
        fprintf(logf, "exit_status=%d\n", 0);
        return 0;
    }
}
